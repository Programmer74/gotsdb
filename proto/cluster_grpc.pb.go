// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*AliveNodesResponse, error)
	GetAliveNodes(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AliveNodesResponse, error)
	KvsSave(ctx context.Context, in *KvsStoreRequest, opts ...grpc.CallOption) (*KvsStoreResponse, error)
	KvsKeyExists(ctx context.Context, in *KvsKeyExistsRequest, opts ...grpc.CallOption) (*KvsKeyExistsResponse, error)
	KvsRetrieve(ctx context.Context, in *KvsRetrieveRequest, opts ...grpc.CallOption) (*KvsRetrieveResponse, error)
	KvsDelete(ctx context.Context, in *KvsDeleteRequest, opts ...grpc.CallOption) (*KvsDeleteResponse, error)
	KvsGetKeys(ctx context.Context, in *KvsAllKeysRequest, opts ...grpc.CallOption) (*KvsAllKeysResponse, error)
	TSSave(ctx context.Context, in *TSStoreRequest, opts ...grpc.CallOption) (*TSStoreResponse, error)
	TSSaveBatch(ctx context.Context, in *TSStoreBatchRequest, opts ...grpc.CallOption) (*TSStoreResponse, error)
	TSRetrieve(ctx context.Context, in *TSRetrieveRequest, opts ...grpc.CallOption) (*TSRetrieveResponse, error)
	TSAvailability(ctx context.Context, in *TSAvailabilityRequest, opts ...grpc.CallOption) (*TSAvailabilityResponse, error)
}

type clusterClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterClient(cc grpc.ClientConnInterface) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*AliveNodesResponse, error) {
	out := new(AliveNodesResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/Hello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetAliveNodes(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AliveNodesResponse, error) {
	out := new(AliveNodesResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/GetAliveNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) KvsSave(ctx context.Context, in *KvsStoreRequest, opts ...grpc.CallOption) (*KvsStoreResponse, error) {
	out := new(KvsStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/KvsSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) KvsKeyExists(ctx context.Context, in *KvsKeyExistsRequest, opts ...grpc.CallOption) (*KvsKeyExistsResponse, error) {
	out := new(KvsKeyExistsResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/KvsKeyExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) KvsRetrieve(ctx context.Context, in *KvsRetrieveRequest, opts ...grpc.CallOption) (*KvsRetrieveResponse, error) {
	out := new(KvsRetrieveResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/KvsRetrieve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) KvsDelete(ctx context.Context, in *KvsDeleteRequest, opts ...grpc.CallOption) (*KvsDeleteResponse, error) {
	out := new(KvsDeleteResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/KvsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) KvsGetKeys(ctx context.Context, in *KvsAllKeysRequest, opts ...grpc.CallOption) (*KvsAllKeysResponse, error) {
	out := new(KvsAllKeysResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/KvsGetKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) TSSave(ctx context.Context, in *TSStoreRequest, opts ...grpc.CallOption) (*TSStoreResponse, error) {
	out := new(TSStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/TSSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) TSSaveBatch(ctx context.Context, in *TSStoreBatchRequest, opts ...grpc.CallOption) (*TSStoreResponse, error) {
	out := new(TSStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/TSSaveBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) TSRetrieve(ctx context.Context, in *TSRetrieveRequest, opts ...grpc.CallOption) (*TSRetrieveResponse, error) {
	out := new(TSRetrieveResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/TSRetrieve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) TSAvailability(ctx context.Context, in *TSAvailabilityRequest, opts ...grpc.CallOption) (*TSAvailabilityResponse, error) {
	out := new(TSAvailabilityResponse)
	err := c.cc.Invoke(ctx, "/proto.Cluster/TSAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServer is the server API for Cluster service.
// All implementations must embed UnimplementedClusterServer
// for forward compatibility
type ClusterServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	Hello(context.Context, *HelloRequest) (*AliveNodesResponse, error)
	GetAliveNodes(context.Context, *Void) (*AliveNodesResponse, error)
	KvsSave(context.Context, *KvsStoreRequest) (*KvsStoreResponse, error)
	KvsKeyExists(context.Context, *KvsKeyExistsRequest) (*KvsKeyExistsResponse, error)
	KvsRetrieve(context.Context, *KvsRetrieveRequest) (*KvsRetrieveResponse, error)
	KvsDelete(context.Context, *KvsDeleteRequest) (*KvsDeleteResponse, error)
	KvsGetKeys(context.Context, *KvsAllKeysRequest) (*KvsAllKeysResponse, error)
	TSSave(context.Context, *TSStoreRequest) (*TSStoreResponse, error)
	TSSaveBatch(context.Context, *TSStoreBatchRequest) (*TSStoreResponse, error)
	TSRetrieve(context.Context, *TSRetrieveRequest) (*TSRetrieveResponse, error)
	TSAvailability(context.Context, *TSAvailabilityRequest) (*TSAvailabilityResponse, error)
	mustEmbedUnimplementedClusterServer()
}

// UnimplementedClusterServer must be embedded to have forward compatible implementations.
type UnimplementedClusterServer struct {
}

func (UnimplementedClusterServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedClusterServer) Hello(context.Context, *HelloRequest) (*AliveNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hello not implemented")
}
func (UnimplementedClusterServer) GetAliveNodes(context.Context, *Void) (*AliveNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAliveNodes not implemented")
}
func (UnimplementedClusterServer) KvsSave(context.Context, *KvsStoreRequest) (*KvsStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsSave not implemented")
}
func (UnimplementedClusterServer) KvsKeyExists(context.Context, *KvsKeyExistsRequest) (*KvsKeyExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsKeyExists not implemented")
}
func (UnimplementedClusterServer) KvsRetrieve(context.Context, *KvsRetrieveRequest) (*KvsRetrieveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsRetrieve not implemented")
}
func (UnimplementedClusterServer) KvsDelete(context.Context, *KvsDeleteRequest) (*KvsDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsDelete not implemented")
}
func (UnimplementedClusterServer) KvsGetKeys(context.Context, *KvsAllKeysRequest) (*KvsAllKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsGetKeys not implemented")
}
func (UnimplementedClusterServer) TSSave(context.Context, *TSStoreRequest) (*TSStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSSave not implemented")
}
func (UnimplementedClusterServer) TSSaveBatch(context.Context, *TSStoreBatchRequest) (*TSStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSSaveBatch not implemented")
}
func (UnimplementedClusterServer) TSRetrieve(context.Context, *TSRetrieveRequest) (*TSRetrieveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSRetrieve not implemented")
}
func (UnimplementedClusterServer) TSAvailability(context.Context, *TSAvailabilityRequest) (*TSAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSAvailability not implemented")
}
func (UnimplementedClusterServer) mustEmbedUnimplementedClusterServer() {}

// UnsafeClusterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServer will
// result in compilation errors.
type UnsafeClusterServer interface {
	mustEmbedUnimplementedClusterServer()
}

func RegisterClusterServer(s grpc.ServiceRegistrar, srv ClusterServer) {
	s.RegisterService(&Cluster_ServiceDesc, srv)
}

func _Cluster_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_Hello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).Hello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/Hello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).Hello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetAliveNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetAliveNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/GetAliveNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetAliveNodes(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_KvsSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).KvsSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/KvsSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).KvsSave(ctx, req.(*KvsStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_KvsKeyExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsKeyExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).KvsKeyExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/KvsKeyExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).KvsKeyExists(ctx, req.(*KvsKeyExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_KvsRetrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).KvsRetrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/KvsRetrieve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).KvsRetrieve(ctx, req.(*KvsRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_KvsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).KvsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/KvsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).KvsDelete(ctx, req.(*KvsDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_KvsGetKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsAllKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).KvsGetKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/KvsGetKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).KvsGetKeys(ctx, req.(*KvsAllKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_TSSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).TSSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/TSSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).TSSave(ctx, req.(*TSStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_TSSaveBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSStoreBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).TSSaveBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/TSSaveBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).TSSaveBatch(ctx, req.(*TSStoreBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_TSRetrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).TSRetrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/TSRetrieve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).TSRetrieve(ctx, req.(*TSRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_TSAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).TSAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Cluster/TSAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).TSAvailability(ctx, req.(*TSAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Cluster_ServiceDesc is the grpc.ServiceDesc for Cluster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cluster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Cluster_Ping_Handler,
		},
		{
			MethodName: "Hello",
			Handler:    _Cluster_Hello_Handler,
		},
		{
			MethodName: "GetAliveNodes",
			Handler:    _Cluster_GetAliveNodes_Handler,
		},
		{
			MethodName: "KvsSave",
			Handler:    _Cluster_KvsSave_Handler,
		},
		{
			MethodName: "KvsKeyExists",
			Handler:    _Cluster_KvsKeyExists_Handler,
		},
		{
			MethodName: "KvsRetrieve",
			Handler:    _Cluster_KvsRetrieve_Handler,
		},
		{
			MethodName: "KvsDelete",
			Handler:    _Cluster_KvsDelete_Handler,
		},
		{
			MethodName: "KvsGetKeys",
			Handler:    _Cluster_KvsGetKeys_Handler,
		},
		{
			MethodName: "TSSave",
			Handler:    _Cluster_TSSave_Handler,
		},
		{
			MethodName: "TSSaveBatch",
			Handler:    _Cluster_TSSaveBatch_Handler,
		},
		{
			MethodName: "TSRetrieve",
			Handler:    _Cluster_TSRetrieve_Handler,
		},
		{
			MethodName: "TSAvailability",
			Handler:    _Cluster_TSAvailability_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cluster.proto",
}
