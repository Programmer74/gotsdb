// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GoTSDBClient is the client API for GoTSDB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoTSDBClient interface {
	KvsSave(ctx context.Context, in *KvsStoreRequest, opts ...grpc.CallOption) (*KvsStoreResponse, error)
	KvsKeyExists(ctx context.Context, in *KvsKeyExistsRequest, opts ...grpc.CallOption) (*KvsKeyExistsResponse, error)
	KvsRetrieve(ctx context.Context, in *KvsRetrieveRequest, opts ...grpc.CallOption) (*KvsRetrieveResponse, error)
	KvsDelete(ctx context.Context, in *KvsDeleteRequest, opts ...grpc.CallOption) (*KvsDeleteResponse, error)
	KvsGetKeys(ctx context.Context, in *KvsAllKeysRequest, opts ...grpc.CallOption) (*KvsAllKeysResponse, error)
	TSSave(ctx context.Context, in *TSStoreRequest, opts ...grpc.CallOption) (*TSStoreResponse, error)
	TSSaveBatch(ctx context.Context, in *TSStoreBatchRequest, opts ...grpc.CallOption) (*TSStoreResponse, error)
	TSRetrieve(ctx context.Context, in *TSRetrieveRequest, opts ...grpc.CallOption) (*TSRetrieveResponse, error)
	TSAvailability(ctx context.Context, in *TSAvailabilityRequest, opts ...grpc.CallOption) (*TSAvailabilityResponse, error)
}

type goTSDBClient struct {
	cc grpc.ClientConnInterface
}

func NewGoTSDBClient(cc grpc.ClientConnInterface) GoTSDBClient {
	return &goTSDBClient{cc}
}

func (c *goTSDBClient) KvsSave(ctx context.Context, in *KvsStoreRequest, opts ...grpc.CallOption) (*KvsStoreResponse, error) {
	out := new(KvsStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/KvsSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) KvsKeyExists(ctx context.Context, in *KvsKeyExistsRequest, opts ...grpc.CallOption) (*KvsKeyExistsResponse, error) {
	out := new(KvsKeyExistsResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/KvsKeyExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) KvsRetrieve(ctx context.Context, in *KvsRetrieveRequest, opts ...grpc.CallOption) (*KvsRetrieveResponse, error) {
	out := new(KvsRetrieveResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/KvsRetrieve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) KvsDelete(ctx context.Context, in *KvsDeleteRequest, opts ...grpc.CallOption) (*KvsDeleteResponse, error) {
	out := new(KvsDeleteResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/KvsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) KvsGetKeys(ctx context.Context, in *KvsAllKeysRequest, opts ...grpc.CallOption) (*KvsAllKeysResponse, error) {
	out := new(KvsAllKeysResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/KvsGetKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) TSSave(ctx context.Context, in *TSStoreRequest, opts ...grpc.CallOption) (*TSStoreResponse, error) {
	out := new(TSStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/TSSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) TSSaveBatch(ctx context.Context, in *TSStoreBatchRequest, opts ...grpc.CallOption) (*TSStoreResponse, error) {
	out := new(TSStoreResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/TSSaveBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) TSRetrieve(ctx context.Context, in *TSRetrieveRequest, opts ...grpc.CallOption) (*TSRetrieveResponse, error) {
	out := new(TSRetrieveResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/TSRetrieve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goTSDBClient) TSAvailability(ctx context.Context, in *TSAvailabilityRequest, opts ...grpc.CallOption) (*TSAvailabilityResponse, error) {
	out := new(TSAvailabilityResponse)
	err := c.cc.Invoke(ctx, "/proto.GoTSDB/TSAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoTSDBServer is the server API for GoTSDB service.
// All implementations must embed UnimplementedGoTSDBServer
// for forward compatibility
type GoTSDBServer interface {
	KvsSave(context.Context, *KvsStoreRequest) (*KvsStoreResponse, error)
	KvsKeyExists(context.Context, *KvsKeyExistsRequest) (*KvsKeyExistsResponse, error)
	KvsRetrieve(context.Context, *KvsRetrieveRequest) (*KvsRetrieveResponse, error)
	KvsDelete(context.Context, *KvsDeleteRequest) (*KvsDeleteResponse, error)
	KvsGetKeys(context.Context, *KvsAllKeysRequest) (*KvsAllKeysResponse, error)
	TSSave(context.Context, *TSStoreRequest) (*TSStoreResponse, error)
	TSSaveBatch(context.Context, *TSStoreBatchRequest) (*TSStoreResponse, error)
	TSRetrieve(context.Context, *TSRetrieveRequest) (*TSRetrieveResponse, error)
	TSAvailability(context.Context, *TSAvailabilityRequest) (*TSAvailabilityResponse, error)
	mustEmbedUnimplementedGoTSDBServer()
}

// UnimplementedGoTSDBServer must be embedded to have forward compatible implementations.
type UnimplementedGoTSDBServer struct {
}

func (UnimplementedGoTSDBServer) KvsSave(context.Context, *KvsStoreRequest) (*KvsStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsSave not implemented")
}
func (UnimplementedGoTSDBServer) KvsKeyExists(context.Context, *KvsKeyExistsRequest) (*KvsKeyExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsKeyExists not implemented")
}
func (UnimplementedGoTSDBServer) KvsRetrieve(context.Context, *KvsRetrieveRequest) (*KvsRetrieveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsRetrieve not implemented")
}
func (UnimplementedGoTSDBServer) KvsDelete(context.Context, *KvsDeleteRequest) (*KvsDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsDelete not implemented")
}
func (UnimplementedGoTSDBServer) KvsGetKeys(context.Context, *KvsAllKeysRequest) (*KvsAllKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KvsGetKeys not implemented")
}
func (UnimplementedGoTSDBServer) TSSave(context.Context, *TSStoreRequest) (*TSStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSSave not implemented")
}
func (UnimplementedGoTSDBServer) TSSaveBatch(context.Context, *TSStoreBatchRequest) (*TSStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSSaveBatch not implemented")
}
func (UnimplementedGoTSDBServer) TSRetrieve(context.Context, *TSRetrieveRequest) (*TSRetrieveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSRetrieve not implemented")
}
func (UnimplementedGoTSDBServer) TSAvailability(context.Context, *TSAvailabilityRequest) (*TSAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TSAvailability not implemented")
}
func (UnimplementedGoTSDBServer) mustEmbedUnimplementedGoTSDBServer() {}

// UnsafeGoTSDBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoTSDBServer will
// result in compilation errors.
type UnsafeGoTSDBServer interface {
	mustEmbedUnimplementedGoTSDBServer()
}

func RegisterGoTSDBServer(s grpc.ServiceRegistrar, srv GoTSDBServer) {
	s.RegisterService(&GoTSDB_ServiceDesc, srv)
}

func _GoTSDB_KvsSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).KvsSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/KvsSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).KvsSave(ctx, req.(*KvsStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_KvsKeyExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsKeyExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).KvsKeyExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/KvsKeyExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).KvsKeyExists(ctx, req.(*KvsKeyExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_KvsRetrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).KvsRetrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/KvsRetrieve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).KvsRetrieve(ctx, req.(*KvsRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_KvsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).KvsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/KvsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).KvsDelete(ctx, req.(*KvsDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_KvsGetKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvsAllKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).KvsGetKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/KvsGetKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).KvsGetKeys(ctx, req.(*KvsAllKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_TSSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).TSSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/TSSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).TSSave(ctx, req.(*TSStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_TSSaveBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSStoreBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).TSSaveBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/TSSaveBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).TSSaveBatch(ctx, req.(*TSStoreBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_TSRetrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).TSRetrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/TSRetrieve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).TSRetrieve(ctx, req.(*TSRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoTSDB_TSAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TSAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoTSDBServer).TSAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GoTSDB/TSAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoTSDBServer).TSAvailability(ctx, req.(*TSAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GoTSDB_ServiceDesc is the grpc.ServiceDesc for GoTSDB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GoTSDB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.GoTSDB",
	HandlerType: (*GoTSDBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "KvsSave",
			Handler:    _GoTSDB_KvsSave_Handler,
		},
		{
			MethodName: "KvsKeyExists",
			Handler:    _GoTSDB_KvsKeyExists_Handler,
		},
		{
			MethodName: "KvsRetrieve",
			Handler:    _GoTSDB_KvsRetrieve_Handler,
		},
		{
			MethodName: "KvsDelete",
			Handler:    _GoTSDB_KvsDelete_Handler,
		},
		{
			MethodName: "KvsGetKeys",
			Handler:    _GoTSDB_KvsGetKeys_Handler,
		},
		{
			MethodName: "TSSave",
			Handler:    _GoTSDB_TSSave_Handler,
		},
		{
			MethodName: "TSSaveBatch",
			Handler:    _GoTSDB_TSSaveBatch_Handler,
		},
		{
			MethodName: "TSRetrieve",
			Handler:    _GoTSDB_TSRetrieve_Handler,
		},
		{
			MethodName: "TSAvailability",
			Handler:    _GoTSDB_TSAvailability_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/rpc.proto",
}
